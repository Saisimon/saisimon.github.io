<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>排序 | Saisimon&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="排序算法(Sorting algorithm)&amp;emsp;&amp;emsp;顾名思义就是将一串数据依照特定排序方式进行排列的一种算法。排序算法各式各样，各有各的特定使用场景，常用的简单排序有：归并排序、快速排序、堆排序、插入排序、希尔排序、基数排序、冒泡排序、选择排序、桶排序等

常见排序算法的复杂度与稳定性




名称
最优
平均
最差
空间
稳定
方式




归并排序
$O(n*log n)$">
<meta property="og:type" content="article">
<meta property="og:title" content="排序">
<meta property="og:url" content="http://blog.saisimon.net/2016/06/16/排序/index.html">
<meta property="og:site_name" content="Saisimon's Blog">
<meta property="og:description" content="排序算法(Sorting algorithm)&amp;emsp;&amp;emsp;顾名思义就是将一串数据依照特定排序方式进行排列的一种算法。排序算法各式各样，各有各的特定使用场景，常用的简单排序有：归并排序、快速排序、堆排序、插入排序、希尔排序、基数排序、冒泡排序、选择排序、桶排序等

常见排序算法的复杂度与稳定性




名称
最优
平均
最差
空间
稳定
方式




归并排序
$O(n*log n)$">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif">
<meta property="og:image" content="http://ww3.sinaimg.cn/mw690/7c2c72d3gw1f4xgrozyptj20m80ci0tw.jpg">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif">
<meta property="og:image" content="http://ww2.sinaimg.cn/mw690/7c2c72d3gw1f4xgqsi3lbj20m80cht9x.jpg">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/4/4d/Heapsort-example.gif">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif">
<meta property="og:updated_time" content="2016-07-22T05:59:06.053Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="排序">
<meta name="twitter:description" content="排序算法(Sorting algorithm)&amp;emsp;&amp;emsp;顾名思义就是将一串数据依照特定排序方式进行排列的一种算法。排序算法各式各样，各有各的特定使用场景，常用的简单排序有：归并排序、快速排序、堆排序、插入排序、希尔排序、基数排序、冒泡排序、选择排序、桶排序等

常见排序算法的复杂度与稳定性




名称
最优
平均
最差
空间
稳定
方式




归并排序
$O(n*log n)$">
  
    <link rel="alternative" href="/atom.xml" title="Saisimon&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://ww1.sinaimg.cn/large/7c2c72d3gw1f2ojznhf9tj205k05kmy7.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Saisimon</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>標籤</li>
						
						
						<li>關於</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Saisimon" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/Saisimon" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/saisimon" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/DWR/" style="font-size: 10px;">DWR</a> <a href="/tags/GitHub/" style="font-size: 10px;">GitHub</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Hibernate/" style="font-size: 15px;">Hibernate</a> <a href="/tags/JSON/" style="font-size: 10px;">JSON</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/ManyToOne/" style="font-size: 10px;">ManyToOne</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/OneToMany/" style="font-size: 10px;">OneToMany</a> <a href="/tags/Quartz/" style="font-size: 10px;">Quartz</a> <a href="/tags/SessionFactory/" style="font-size: 10px;">SessionFactory</a> <a href="/tags/cron/" style="font-size: 10px;">cron</a> <a href="/tags/博客/" style="font-size: 10px;">博客</a> <a href="/tags/应用/" style="font-size: 10px;">应用</a> <a href="/tags/排序/" style="font-size: 10px;">排序</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/解析/" style="font-size: 10px;">解析</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">SteamID:simonzs,PSN:Sai_zs93</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Saisimon</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://ww1.sinaimg.cn/large/7c2c72d3gw1f2ojznhf9tj205k05kmy7.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Saisimon</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Saisimon" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/Saisimon" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/saisimon" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-排序" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/16/排序/" class="article-date">
  	<time datetime="2016-06-16T04:55:53.000Z" itemprop="datePublished">2016-06-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      排序
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/排序/">排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/算法/">算法</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="u6392_u5E8F_u7B97_u6CD5_28Sorting_algorithm_29"><a href="#u6392_u5E8F_u7B97_u6CD5_28Sorting_algorithm_29" class="headerlink" title="排序算法(Sorting algorithm)"></a>排序算法(Sorting algorithm)</h1><p>&emsp;&emsp;顾名思义就是将一串数据依照特定排序方式进行排列的一种算法。排序算法各式各样，各有各的特定使用场景，常用的简单排序有：归并排序、快速排序、堆排序、插入排序、希尔排序、基数排序、冒泡排序、选择排序、桶排序等</p>
<ul>
<li>常见排序算法的复杂度与稳定性</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>最优</th>
<th>平均</th>
<th>最差</th>
<th>空间</th>
<th>稳定</th>
<th>方式</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/2016/06/16/排序#mergeSort">归并排序</a></td>
<td>$O(n*log n)$</td>
<td>$O(n*log n)$</td>
<td>$O(n*log n)$</td>
<td>$O(n)$</td>
<td>Yes</td>
<td>合并</td>
</tr>
<tr>
<td><a href="/2016/06/16/排序#quickSort">快速排序</a></td>
<td>$O(n*log n)$</td>
<td>$O(n*log n)$</td>
<td>$O(n^2)$</td>
<td>$O(log n)$</td>
<td>No</td>
<td>分割</td>
</tr>
<tr>
<td><a href="/2016/06/16/排序#heapSort">堆排序</a></td>
<td>$O(n*log n)$</td>
<td>$O(n*log n)$</td>
<td>$O(n*log n)$</td>
<td>$O(1)$</td>
<td>No</td>
<td>选择</td>
</tr>
<tr>
<td><a href="/2016/06/16/排序#insertSort">插入排序</a></td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>Yes</td>
<td>插入</td>
</tr>
<tr>
<td><a href="/2016/06/16/排序#shellSort">希尔排序</a></td>
<td>$O(n)$</td>
<td>$O(n*log^2 n)$</td>
<td>$O(n*log^2 n)$</td>
<td>$O(1)$</td>
<td>No</td>
<td>插入</td>
</tr>
<tr>
<td><a href="/2016/06/16/排序#bubbleSort">冒泡排序</a></td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>Yes</td>
<td>交换</td>
</tr>
<tr>
<td><a href="/2016/06/16/排序#selectSort">选择排序</a></td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>Yes</td>
<td>选择</td>
</tr>
<tr>
<td><a href="/2016/06/16/排序#radixSort">基数排序</a></td>
<td>-</td>
<td>$O(n*k)$</td>
<td>O($n*k$)</td>
<td>$O(n+k)$</td>
<td>Yes</td>
<td>-</td>
</tr>
<tr>
<td><a href="/2016/06/16/排序#bucketSort">桶排序</a></td>
<td>-</td>
<td>$O(n+k)$</td>
<td>$O(n^2*k)$</td>
<td>$O(n*k)$</td>
<td>Yes</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><small>注：稳定表示相同的数据在排序前后在相对位置一致，例如 3，2，1，3 中第一个3在排序后应该也是第一个 3</small></p>
<a id="more"></a>    
<p><br><br><br></p>
<h2 id="u5F52_u5E76_u6392_u5E8F_28Merge_sort_29"><a href="#u5F52_u5E76_u6392_u5E8F_28Merge_sort_29" class="headerlink" title="归并排序(Merge sort)"></a><a id="mergeSort"></a><a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="external">归并排序</a>(<a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="external">Merge sort</a>)</h2><p>&emsp;&emsp;归并排序运用了一种分治的方法，将一个复杂的问题进行分成两个或两个以上的子问题，直到将问题变成一个可以用简单的方式解决，然后将子问题的解进行合并，最终得到原问题的答案。归并排序即先递归分割待排序数据，然后再进行合并操作。</p>
<ul>
<li>复杂度与稳定性</li>
</ul>
<table>
<thead>
<tr>
<th>复杂度</th>
<th>复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>最差时间复杂度</td>
<td>$O(n*log n)$</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>$O(n*log n)$</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>$O(n*log n)$</td>
</tr>
<tr>
<td>最差空间复杂度</td>
<td>$O(n)$</td>
</tr>
<tr>
<td>稳定</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<ul>
<li><p>算法伪代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor"># split in half</span></span><br><span class="line">m = n / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># recursive sorts</span></span><br><span class="line">sort a[<span class="number">1.</span>.m]</span><br><span class="line">sort a[m+<span class="number">1.</span>.n]</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># merge sorted sub-arrays using temp array</span></span><br><span class="line">b = copy of a[<span class="number">1.</span>.m]</span><br><span class="line">i = <span class="number">1</span>, j = m+<span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= m and j &lt;= n,</span><br><span class="line">    a[k++] = (a[j] &lt; b[i]) ? a[j++] : b[i++]</span><br><span class="line">    → invariant: a[<span class="number">1.</span>.k] in final position</span><br><span class="line"><span class="keyword">while</span> i &lt;= m,</span><br><span class="line">    a[k++] = b[i++]</span><br><span class="line">    → invariant: a[<span class="number">1.</span>.k] in final position</span><br></pre></td></tr></table></figure>
</li>
<li><p>可视化归并排序算法<br><img src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif" alt="image"><br><small>图片来自wikipedia</small></p>
</li>
<li><p>java实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 归并排序</span><br><span class="line"> * 先递归再合并</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> a 待排序数组</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	mergeSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span> || start &lt; <span class="number">0</span> || end &gt;= a.length) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找中值</span></span><br><span class="line">	<span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 递归调用</span></span><br><span class="line">	mergeSort(a, start, middle);</span><br><span class="line">	mergeSort(a, middle + <span class="number">1</span>, end);</span><br><span class="line">	<span class="comment">// 合并</span></span><br><span class="line">	sorts(a, start, middle, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sorts</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> middle, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = end - start + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 如果只有两个元素，直接比较</span></span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[start] &gt; a[end]) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp = a[start];</span><br><span class="line">			a[start] = a[end];</span><br><span class="line">			a[end] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 临时数组，用于存储比较之后的元素</span></span><br><span class="line">	<span class="comment">// a = [1,3,5,2,4,6] -&gt; [1,3,5] + [2,4,6]</span></span><br><span class="line">	<span class="comment">// [1,3,5]  [2,4,6]</span></span><br><span class="line">	<span class="comment">//  -        -  </span></span><br><span class="line">	<span class="comment">// [1 &lt; 2] -&gt; c = [1,0,0,0,0,0]</span></span><br><span class="line">	<span class="comment">// [2 &lt; 3] -&gt; c = [1,2,0,0,0,0]</span></span><br><span class="line">	<span class="comment">//  ...</span></span><br><span class="line">	<span class="comment">// [6]     -&gt; c = [1,2,3,4,5,6]</span></span><br><span class="line">	<span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">	<span class="keyword">int</span> k = start;</span><br><span class="line">	<span class="keyword">int</span> j = middle + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k &gt; middle) &#123;</span><br><span class="line">			<span class="comment">//只剩第二个数组中的元素</span></span><br><span class="line">			c[i] = a[j];</span><br><span class="line">			j++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j &gt; end) &#123;</span><br><span class="line">			<span class="comment">//只剩第一个数组中的元素</span></span><br><span class="line">			c[i] = a[k];</span><br><span class="line">			k++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[k] &lt;= a[j]) &#123;</span><br><span class="line">			c[i] = a[k];</span><br><span class="line">			k++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c[i] = a[j];</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将c数组中的元素填充回a数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		a[start + i] = c[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br><br><br></p>
<h2 id="u5FEB_u901F_u6392_u5E8F_28Quick_sort_29"><a href="#u5FEB_u901F_u6392_u5E8F_28Quick_sort_29" class="headerlink" title="快速排序(Quick sort)"></a><a id="quickSort"></a><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="external">快速排序</a>(<a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="external">Quick sort</a>)</h2><p>&emsp;&emsp;快速排序是一种比较排序，以某个基准(pivot)为界限，进行划分，然后进行交换，所以又被称为划分交换排序（partition-exchange sort）</p>
<ul>
<li>复杂度与稳定性</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>最差时间复杂度</td>
<td>$O(n^2)$</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>$O(n*log n)$</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>$O(n*log n)$</td>
</tr>
<tr>
<td>最差空间复杂度</td>
<td>$O(n)$</td>
</tr>
<tr>
<td>稳定</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<h3 id="u5206_u6210_u4E24_u90E8_u5206_u8FDB_u884C_u6392_u5E8F"><a href="#u5206_u6210_u4E24_u90E8_u5206_u8FDB_u884C_u6392_u5E8F" class="headerlink" title="分成两部分进行排序"></a>分成两部分进行排序</h3><ul>
<li>2-way 快速排序的步骤</li>
</ul>
<p>&emsp;&emsp;快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p>
<p>&emsp;&emsp;1. 从数列中挑出一个元素，称为”基准”（pivot），<br>&emsp;&emsp;2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br>&emsp;&emsp;3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<p>&emsp;&emsp;<img src="http://ww3.sinaimg.cn/mw690/7c2c72d3gw1f4xgrozyptj20m80ci0tw.jpg" alt="image"></p>
<ul>
<li>算法伪代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor"># choose pivot</span></span><br><span class="line">swap a[<span class="number">1</span>,rand(<span class="number">1</span>,n)]</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># <span class="number">2</span>-way partition</span></span><br><span class="line">k = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">2</span>:n, <span class="keyword">if</span> a[i] &lt; a[<span class="number">1</span>], swap a[++k,i]</span><br><span class="line">swap a[<span class="number">1</span>,k]</span><br><span class="line">→ invariant: a[<span class="number">1.</span>.k-<span class="number">1</span>] &lt; a[k] &lt;= a[k+<span class="number">1.</span>.n]</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># recursive sorts</span></span><br><span class="line">sort a[<span class="number">1.</span>.k-<span class="number">1</span>]</span><br><span class="line">sort a[k+<span class="number">1</span>,n]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可视化快速排序算法<br><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="image"><br><small>图片来自wikipedia</small></p>
</li>
<li><p>java实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 快速排序 (分两部分)</span><br><span class="line"> * 分成两部分，再递归调用</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> a 待排序数组</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	quickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span> || start &lt; <span class="number">0</span> || end &gt;= a.length) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 分段，找到idx,使得idx前面的值都小于k，idx后面的值都大于k</span></span><br><span class="line">	<span class="keyword">int</span> idx = partition(a, start, end);</span><br><span class="line">	<span class="comment">// 递归调用</span></span><br><span class="line">	<span class="keyword">if</span> (idx &gt; start) &#123;</span><br><span class="line">		quickSort(a, start, idx - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 递归调用</span></span><br><span class="line">	<span class="keyword">if</span> (idx &lt; end) &#123;</span><br><span class="line">		quickSort(a, idx + <span class="number">1</span>, end);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 首部</span></span><br><span class="line">	<span class="keyword">int</span> i = start;</span><br><span class="line">	<span class="comment">// 尾部</span></span><br><span class="line">	<span class="keyword">int</span> j = end;</span><br><span class="line">	<span class="comment">// 比较值</span></span><br><span class="line">	<span class="keyword">int</span> k = a[start];</span><br><span class="line">	<span class="keyword">while</span> (j &gt; i) &#123;</span><br><span class="line">		<span class="comment">// 从末尾开始和k进行比较，保证当前末尾的值都大于等于k</span></span><br><span class="line">		<span class="keyword">while</span> (j &gt; i &amp;&amp; a[j] &gt;= k) &#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当当前末尾的小于k时，交换当前首部和当前尾部的值</span></span><br><span class="line">		<span class="keyword">if</span> (j &gt; i) &#123;</span><br><span class="line">			a[i] = a[j];</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 再从当前首部开始和k进行比较，保证当前首部的值都小于等于k</span></span><br><span class="line">		<span class="keyword">while</span> (j &gt; i &amp;&amp; a[i] &lt;= k) &#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当当前首部的值大于k时，交换当前尾部和当前首部的值</span></span><br><span class="line">		<span class="keyword">if</span> (j &gt; i) &#123;</span><br><span class="line">			a[j] = a[i];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 首尾相遇，当前首部的值为比较值</span></span><br><span class="line">	a[i] = k;</span><br><span class="line">	<span class="comment">// 返回当前比较值所在位置，用于递归调用，这是i前面的值都小于k，i后面的值都大于k</span></span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u5206_u6210_u4E09_u4E2A_u90E8_u5206_u8FDB_u884C_u6392_u5E8F_283_Way_Partition_29"><a href="#u5206_u6210_u4E09_u4E2A_u90E8_u5206_u8FDB_u884C_u6392_u5E8F_283_Way_Partition_29" class="headerlink" title="分成三个部分进行排序(3 Way Partition)"></a>分成三个部分进行排序(3 Way Partition)</h3><ul>
<li>3-way 快速排序的步骤</li>
</ul>
<ol>
<li>依旧从数列中挑出一个元素，称为”基准”（pivot），</li>
<li>基准左边的数据都小于基准，右边的数据都大于基准，其他的为与基准相等的数据</li>
<li>递归调用，把小于基准值元素的子数列和大于基准值元素的子数列排序。<br><img src="http://ww2.sinaimg.cn/mw690/7c2c72d3gw1f4xgqsi3lbj20m80cht9x.jpg" alt="image"></li>
</ol>
<ul>
<li>算法伪代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor"># choose pivot</span></span><br><span class="line">swap a[n,rand(<span class="number">1</span>,n)]</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># <span class="number">3</span>-way partition</span></span><br><span class="line">i = <span class="number">1</span>, k = <span class="number">1</span>, p = n</span><br><span class="line"><span class="keyword">while</span> i &lt; p,</span><br><span class="line">  <span class="keyword">if</span> a[i] &lt; a[n], swap a[i++,k++]</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> a[i] == a[n], swap a[i,--p]</span><br><span class="line">  <span class="keyword">else</span> i++</span><br><span class="line">end</span><br><span class="line">→ invariant: a[p..n] all equal</span><br><span class="line">→ invariant: a[<span class="number">1.</span>.k-<span class="number">1</span>] &lt; a[p..n] &lt; a[k..p-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># move pivots to center</span></span><br><span class="line">m = min(p-k,n-p+<span class="number">1</span>)</span><br><span class="line">swap a[k..k+m-<span class="number">1</span>,n-m+<span class="number">1.</span>.n]</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># recursive sorts</span></span><br><span class="line">sort a[<span class="number">1.</span>.k-<span class="number">1</span>]</span><br><span class="line">sort a[n-p+k+<span class="number">1</span>,n]</span><br></pre></td></tr></table></figure>
<ul>
<li>java实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 快速排序(分三部分)</span><br><span class="line"> * 分成三个部分，再递归调用</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> a 待排序数组</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort3</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	quickSort3(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort3</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span> || start &lt; <span class="number">0</span> || end &gt;= a.length) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 当首大于等于尾，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 低位</span></span><br><span class="line">	<span class="keyword">int</span> low = start;</span><br><span class="line">	<span class="comment">// 高位</span></span><br><span class="line">	<span class="keyword">int</span> high = end;</span><br><span class="line">	<span class="comment">// 初始下标</span></span><br><span class="line">	<span class="keyword">int</span> i = start + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 比较值</span></span><br><span class="line">	<span class="keyword">int</span> k = a[start];</span><br><span class="line">	<span class="comment">// 分三段 (小于|等于|大于)</span></span><br><span class="line">	<span class="comment">// k左边的元素都小于k，k右边的元素都大于k，中间为和k相等的元素</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= high) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt; k) &#123;</span><br><span class="line">			swap(a, i, low);</span><br><span class="line">			i++;</span><br><span class="line">			low++;</span><br><span class="line"> 		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; k) &#123;</span><br><span class="line"> 			swap(a, i, high);</span><br><span class="line"> 			high--;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 小于部分递归调用</span></span><br><span class="line">	quickSort3(a, start, low - <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 大于部分递归调用</span></span><br><span class="line">	quickSort3(a, high + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 交换指定数组中的两个元素的位置</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> a 数组</span><br><span class="line"> * <span class="doctag">@param</span> i 第一个元素的下标</span><br><span class="line"> * <span class="doctag">@param</span> j 第二个元素的下标</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span> || i &lt; <span class="number">0</span> || j &gt;= a.length) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> temp = a[i];</span><br><span class="line">	a[i] = a[j];</span><br><span class="line">	a[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="u5806_u6392_u5E8F_28Heap_sort_29"><a href="#u5806_u6392_u5E8F_28Heap_sort_29" class="headerlink" title="堆排序(Heap sort)"></a><a id="heapSort"></a><a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F" target="_blank" rel="external">堆排序</a>(<a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="external">Heap sort</a>)</h2><p>&emsp;&emsp;堆排序（Heapsort）是利用堆这种数据结构所设计的一种排序算法，堆又是一种二叉树，关于二叉树可以参考<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="external">Wiki</a>。</p>
<ul>
<li>复杂度与稳定性</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>最差时间复杂度</td>
<td>$O(n*log n)$</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>$O(n*log n)$</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>$O(n*log n)$</td>
</tr>
<tr>
<td>最差空间复杂度</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>稳定</td>
<td>No</td>
</tr>
</tbody>
</table>
<ul>
<li>堆排序的步骤</li>
</ul>
<ol>
<li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序</li>
<li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>
</ol>
<ul>
<li>算法伪代码</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># heapify</span><br><span class="line">for i = n/2:1, sink(a,i,n)</span><br><span class="line">→ invariant: a[1,n] in heap order</span><br><span class="line"></span><br><span class="line"># sortdown</span><br><span class="line">for i = 1:n,</span><br><span class="line">    swap a[1,n-i+1]</span><br><span class="line">    sink(a,1,n-i)</span><br><span class="line">    → invariant: a[n-i+1,n] in final position</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># sink from i in a[1..n]</span><br><span class="line">function sink(a,i,n):</span><br><span class="line">    # &#123;lc,rc,mc&#125; = &#123;left,right,max&#125; child index</span><br><span class="line">    lc = 2*i</span><br><span class="line">    if lc &gt; n, return # no children</span><br><span class="line">    rc = lc + 1</span><br><span class="line">    mc = (rc &gt; n) ? lc : (a[lc] &gt; a[rc]) ? lc : rc</span><br><span class="line">    if a[i] &gt;= a[mc], return # heap ordered</span><br><span class="line">    swap a[i,mc]</span><br><span class="line">    sink(a,mc,n)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可视化堆排序算法<br><img src="https://upload.wikimedia.org/wikipedia/commons/4/4d/Heapsort-example.gif" alt="image"><br><small>图片来自wikipedia</small></p>
</li>
<li><p>java实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 堆排序</span><br><span class="line"> * 利用堆的特性进行排序</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> a 待排序数组</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	heapSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span> || start &lt; <span class="number">0</span> || end &gt;= a.length) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 当首大于等于尾，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 父节点下标</span></span><br><span class="line">	<span class="keyword">int</span> parent = start;</span><br><span class="line">	<span class="keyword">while</span> (end &gt; start) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> idx = i;</span><br><span class="line">			<span class="comment">// 最大堆调整</span></span><br><span class="line">			<span class="keyword">while</span>(idx &gt; start &amp;&amp; a[idx] &gt; a[parent = ((idx + start - <span class="number">1</span>) / <span class="number">2</span>)]) &#123;</span><br><span class="line">				swap(a, idx, parent);</span><br><span class="line">				idx = parent;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将最大值放到最后</span></span><br><span class="line">		swap(a, start, end);</span><br><span class="line">		end--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="u63D2_u5165_u6392_u5E8F_28Insertion_sort_29"><a href="#u63D2_u5165_u6392_u5E8F_28Insertion_sort_29" class="headerlink" title="插入排序(Insertion sort)"></a><a id="insertSort"></a><a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="external">插入排序</a>(<a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="external">Insertion sort</a>)</h2><p>&emsp;&emsp;插入排序是一种非常直观的排序方式，从第一个元素开始，从后往前比较，然后进行交换操作，直到整个数据遍历完成。这种排序方式只需用到O(1)的额外空间来处理存放临时数据，但是需要不断的把前面的序列进行移位，来插入下一个元素。差不多已经排好序的数据集合使用插入排序的效率更高，这就产生了插入排序的改进方法–希尔排序</p>
<ul>
<li>复杂度与稳定性</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>最差时间复杂度</td>
<td>$O(n^2)$</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>$O(n)$</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>$O(n^2)$</td>
</tr>
<tr>
<td>最差空间复杂度</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>稳定</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<ul>
<li><p>插入排序操作的实现步骤<br>1.从第一个元素开始，该元素可以认为已经被排序<br>2.取出下一个元素，在已经排序的元素序列中从后向前扫描<br>3.如果该元素（已排序）大于新元素，将该元素移到下一位置<br>4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>5.将新元素插入到该位置后<br>6.重复步骤2~5</p>
</li>
<li><p>算法伪代码</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">2</span>:n,</span><br><span class="line">    <span class="keyword">for</span> (k = i; k &gt; <span class="number">1</span> and a[k] &lt; a[k-<span class="number">1</span>]; k--) </span><br><span class="line">        swap a[k,k-<span class="number">1</span>]</span><br><span class="line">    → invariant: a[<span class="number">1.</span>.i] is sorted</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可视化插入排序算法<br><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt="image"><br><small>图片来自wikipedia</small></p>
</li>
<li><p>java 实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 插入排序</span><br><span class="line"> * 遍历数组，比较大小，插入元素</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> a 待排序数组</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	insertSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span> || start &lt; <span class="number">0</span> || end &gt;= a.length) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> k = a[i];</span><br><span class="line">		<span class="comment">// 当前位置的值与k进行比较，如果大于k，就交换</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; k; j--) &#123;</span><br><span class="line">			a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">			a[j] = k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="u5E0C_u5C14_u6392_u5E8F_28Shell_sort_29"><a href="#u5E0C_u5C14_u6392_u5E8F_28Shell_sort_29" class="headerlink" title="希尔排序(Shell sort)"></a><a id="shellSort"></a><a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="external">希尔排序</a>(<a href="https://en.wikipedia.org/wiki/Shell_sort" target="_blank" rel="external">Shell sort</a>)</h2><p>&emsp;&emsp;希尔排序是插入排序的一个改进版本，利用了插入排序在对几乎排好序的数据集合的排序效率为O(n)性质，对数据集合进行分组，然后进行插入排序，指定分组的间隔为1为止，但是希尔排序变成了不稳定的排序方法。</p>
<ul>
<li>复杂度与稳定性</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>最差时间复杂度</td>
<td>$O(n*log^2 n)$</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>$O(n)$</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>$O(n*log^2 n)$</td>
</tr>
<tr>
<td>最差空间复杂度</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>稳定</td>
<td>No</td>
</tr>
</tbody>
</table>
<ul>
<li>算法伪代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">h = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> h &lt; n, h = <span class="number">3</span>*h + <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> h &gt; <span class="number">0</span>,</span><br><span class="line">    h = h / <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> k = <span class="number">1</span>:h, insertion sort a[k:h:n]</span><br><span class="line">    → invariant: each h-sub-<span class="built_in">array</span> is sorted</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ul>
<li>排序实例</li>
</ul>
<ol>
<li><p>待排序数据集合</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">29</span>,<span class="number">18</span>,<span class="number">25</span>,<span class="number">13</span>,<span class="number">20</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">21</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">27</span>,<span class="number">31</span>,<span class="number">22</span>,<span class="number">7</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对其进行步长为7的分组</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">01</span>,<span class="number">29</span>,<span class="number">18</span>,<span class="number">25</span>,<span class="number">13</span>,<span class="number">20</span>,<span class="number">04</span></span><br><span class="line"><span class="number">15</span>,<span class="number">09</span>,<span class="number">21</span>,<span class="number">11</span>,<span class="number">03</span>,<span class="number">10</span>,<span class="number">08</span></span><br><span class="line"><span class="number">27</span>,<span class="number">31</span>,<span class="number">22</span>,<span class="number">07</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对每一列进行插入排序</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">01</span>,<span class="number">09</span>,<span class="number">18</span>,<span class="number">07</span>,<span class="number">03</span>,<span class="number">10</span>,<span class="number">04</span></span><br><span class="line"><span class="number">15</span>,<span class="number">29</span>,<span class="number">21</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">20</span>,<span class="number">08</span></span><br><span class="line"><span class="number">27</span>,<span class="number">31</span>,<span class="number">22</span>,<span class="number">25</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>得到第一次排序结果</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">9</span>,<span class="number">18</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">29</span>,<span class="number">21</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">20</span>,<span class="number">8</span>,<span class="number">27</span>,<span class="number">31</span>,<span class="number">22</span>,<span class="number">25</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再对其进行步长为4的分组</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">01</span>,<span class="number">09</span>,<span class="number">18</span>,<span class="number">07</span></span><br><span class="line"><span class="number">03</span>,<span class="number">10</span>,<span class="number">04</span>,<span class="number">15</span></span><br><span class="line"><span class="number">29</span>,<span class="number">21</span>,<span class="number">11</span>,<span class="number">13</span></span><br><span class="line"><span class="number">20</span>,<span class="number">08</span>,<span class="number">27</span>,<span class="number">31</span></span><br><span class="line"><span class="number">22</span>,<span class="number">25</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再对每一列进行插入排序</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">01</span>,<span class="number">08</span>,<span class="number">04</span>,<span class="number">07</span></span><br><span class="line"><span class="number">03</span>,<span class="number">09</span>,<span class="number">11</span>,<span class="number">13</span></span><br><span class="line"><span class="number">20</span>,<span class="number">10</span>,<span class="number">18</span>,<span class="number">15</span></span><br><span class="line"><span class="number">22</span>,<span class="number">21</span>,<span class="number">27</span>,<span class="number">31</span></span><br><span class="line"><span class="number">29</span>,<span class="number">25</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>得到第二次排序结果</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">18</span>,<span class="number">15</span>,<span class="number">22</span>,<span class="number">21</span>,<span class="number">27</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">25</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后进行步长为1的插入排序，得到最终排好序的结果</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">18</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">25</span>,<span class="number">27</span>,<span class="number">29</span>,<span class="number">31</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&emsp;&emsp;根据上面的实例可以看出步长的选择对排序的效率有很大的影响。最后步长为1时就变成了普通的插入排序。一般选用的步长公式为3*i+1，即1,4,7,10…</p>
<ul>
<li>java 实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 希尔排序</span><br><span class="line"> * 先按指定规则分组，然后组内排序，直到间隔为1</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> a 带排序数组</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	shellSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span> || start &lt; <span class="number">0</span> || end &gt;= a.length) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 间隔数量</span></span><br><span class="line">	<span class="keyword">int</span> gap = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 间隔数量取 gap = gap * 3 + 1， 1,4,13,40...</span></span><br><span class="line">	<span class="keyword">while</span> (gap &lt; (end - start + <span class="number">1</span>) / <span class="number">3</span>) &#123;</span><br><span class="line">		gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 每个间隔的值组成一个组，然后组内做插入排序，直到间隔为1</span></span><br><span class="line">	<span class="comment">// 1 6 2 9 -1 2 7 1 3 2 5</span></span><br><span class="line">	<span class="comment">// |________|_______|</span></span><br><span class="line">	<span class="comment">//   |________|_______|</span></span><br><span class="line">	<span class="comment">//     |________|_______|</span></span><br><span class="line">	<span class="comment">//       |________|</span></span><br><span class="line">	<span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="comment">//插入排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = start + gap; i &lt;= end; i += gap) &#123;</span><br><span class="line">			<span class="keyword">int</span> k = a[i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; k; j -= gap) &#123;</span><br><span class="line">				a[j + gap] = a[j];</span><br><span class="line">				a[j] = k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="u5192_u6CE1_u6392_u5E8F_28Bubble_sort_29"><a href="#u5192_u6CE1_u6392_u5E8F_28Bubble_sort_29" class="headerlink" title="冒泡排序(Bubble sort)"></a><a id="bubbleSort"></a><a href="https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" target="_blank" rel="external">冒泡排序</a>(<a href="https://en.wikipedia.org/wiki/Bubble_sort" target="_blank" rel="external">Bubble sort</a>)</h2><p>&emsp;&emsp;冒泡排序也是一种简单直观的比较排序算法。每次比较两个元素，如果顺序不正确，则交换位置，直到所有元素没有再需要交换为止，也就是说该数列已经排序完成。</p>
<ul>
<li>复杂度与稳定性</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>最差时间复杂度</td>
<td>$O(n^2)$</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>$O(n)$</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>$O(n^2)$</td>
</tr>
<tr>
<td>最差空间复杂度</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>稳定</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<ul>
<li>冒泡排序的实现步骤</li>
</ul>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<ul>
<li>算法伪代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>:n,</span><br><span class="line">    swapped = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> j = n:i+<span class="number">1</span>, </span><br><span class="line">        <span class="keyword">if</span> a[j] &lt; a[j-<span class="number">1</span>], </span><br><span class="line">            swap a[j,j-<span class="number">1</span>]</span><br><span class="line">            swapped = <span class="literal">true</span></span><br><span class="line">    → invariant: a[<span class="number">1.</span>.i] in final position</span><br><span class="line">    <span class="keyword">break</span> <span class="keyword">if</span> not swapped</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可视化冒泡排序算法<br><img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif" alt="image"><br><small>图片来自wikipedia</small></p>
</li>
<li><p>java 实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 冒泡排序</span><br><span class="line"> * 遍历数组，比较大小，最大值放最后</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> a 待排序数组</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	bubbleSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span> || start &lt; <span class="number">0</span> || end &gt;= a.length) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">		<span class="comment">// 当前区域的最后位置			</span></span><br><span class="line">		<span class="keyword">int</span> last = end - i + start;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = start + <span class="number">1</span>; j &lt;= last; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j - <span class="number">1</span>] &gt; a[j]) &#123;</span><br><span class="line">				<span class="comment">// 交换</span></span><br><span class="line">				swap(a, j - <span class="number">1</span>, j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="u9009_u62E9_u6392_u5E8F_28Selection_sort_29"><a href="#u9009_u62E9_u6392_u5E8F_28Selection_sort_29" class="headerlink" title="选择排序(Selection sort)"></a><a id="selectSort"><a href="https://zh.wikipedia.org/wiki/%E9%81%B8%E6%93%87%E6%8E%92%E5%BA%8F" target="_blank" rel="external">选择排序</a>(<a href="https://en.wikipedia.org/wiki/Selection_sort" target="_blank" rel="external">Selection sort</a>)</a></h2><p>&emsp;&emsp;选择排序也是一个非常简单明了的比较排序算法。首先遍历待排序的数列，找出最小的元素，与数列第一个元素交换，然后从第二个元素开始再遍历找出最小的元素，以此类推，直到最后一个元素，这时数列就已经排好序了。</p>
<ul>
<li>复杂度与稳定性</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>最差时间复杂度</td>
<td>$O(n^2)$</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>$O(n^2)$</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>$O(n^2)$</td>
</tr>
<tr>
<td>最差空间复杂度</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>稳定</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<ul>
<li>算法伪代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>:n,</span><br><span class="line">    k = i</span><br><span class="line">    <span class="keyword">for</span> j = i+<span class="number">1</span>:n, <span class="keyword">if</span> a[j] &lt; a[k], k = j</span><br><span class="line">    → invariant: a[k] smallest of a[i..n]</span><br><span class="line">    swap a[i,k]</span><br><span class="line">    → invariant: a[<span class="number">1.</span>.i] in final position</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可视化选择排序算法<br><img src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif" alt="image"><br><small>图片来自wikipedia</small></p>
</li>
<li><p>java 实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 选择排序</span><br><span class="line"> * 遍历数组，比较大小，最小值放前面</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> a 待排序数组</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	selectSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span> || start &lt; <span class="number">0</span> || end &gt;= a.length) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">		<span class="comment">// 当前区域最小值的下标</span></span><br><span class="line">		<span class="keyword">int</span> minIdx = i;</span><br><span class="line">		<span class="comment">// 遍历选出当前区域最小值的下标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= end; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[minIdx] &gt;= a[j]) &#123;</span><br><span class="line">				minIdx = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 交换最小值和当前元素</span></span><br><span class="line">		<span class="keyword">if</span> (minIdx != i) &#123;</span><br><span class="line">			swap(a, minIdx, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="u57FA_u6570_u6392_u5E8F_28Radix_sort_29"><a href="#u57FA_u6570_u6392_u5E8F_28Radix_sort_29" class="headerlink" title="基数排序(Radix sort)"></a><a id="radixSort"></a><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" target="_blank" rel="external">基数排序</a>(<a href="https://en.wikipedia.org/wiki/Radix_sort" target="_blank" rel="external">Radix sort</a>)</h2><p>&emsp;&emsp;基数排序是一种非比较的排序算法，用于对整数进行排序。原理是将数据集合的每一个数据按位数进行比较，位数不足的用0补足，从最低位开始进行依次进行排序，直到排完所有位数。</p>
<ul>
<li>复杂度与稳定性</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>最差时间复杂度</td>
<td>$O(n*k)$</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>$O(n*k)$</td>
</tr>
<tr>
<td>最差空间复杂度</td>
<td>$O(n+k)$</td>
</tr>
<tr>
<td>稳定</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p><small>注：k为数字位数</small></p>
<ul>
<li>排序实例<br>1.待排序数据集合  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">71</span>,<span class="number">2</span>,<span class="number">103</span>,<span class="number">28</span>,<span class="number">19</span>,<span class="number">15</span>,<span class="number">127</span>,<span class="number">391</span>,<span class="number">56</span>,<span class="number">27</span>,<span class="number">49</span>,<span class="number">42</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">194</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2.从个位开始比较<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> : </span><br><span class="line"><span class="number">1</span> : <span class="number">11</span>,<span class="number">71</span>,<span class="number">391</span></span><br><span class="line"><span class="number">2</span> : <span class="number">2</span>,<span class="number">42</span></span><br><span class="line"><span class="number">3</span> : <span class="number">103</span></span><br><span class="line"><span class="number">4</span> : <span class="number">194</span></span><br><span class="line"><span class="number">5</span> : <span class="number">15</span></span><br><span class="line"><span class="number">6</span> : <span class="number">56</span></span><br><span class="line"><span class="number">7</span> : <span class="number">27</span>,<span class="number">127</span></span><br><span class="line"><span class="number">8</span> : <span class="number">8</span>,<span class="number">28</span></span><br><span class="line"><span class="number">9</span> : <span class="number">19</span>,<span class="number">49</span></span><br></pre></td></tr></table></figure></p>
<p>3.得到第一次比较结果<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span>,<span class="number">71</span>,<span class="number">391</span>,<span class="number">2</span>,<span class="number">42</span>,<span class="number">103</span>,<span class="number">194</span>,<span class="number">15</span>,<span class="number">56</span>,<span class="number">27</span>,<span class="number">127</span>,<span class="number">8</span>,<span class="number">28</span>,<span class="number">19</span>,<span class="number">49</span></span><br></pre></td></tr></table></figure></p>
<p>4.在对十位进行比较<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> : <span class="number">2</span>,<span class="number">8</span>,<span class="number">103</span></span><br><span class="line"><span class="number">1</span> : <span class="number">11</span>,<span class="number">15</span>,<span class="number">19</span></span><br><span class="line"><span class="number">2</span> : <span class="number">27</span>,<span class="number">28</span>,<span class="number">127</span></span><br><span class="line"><span class="number">3</span> : </span><br><span class="line"><span class="number">4</span> : <span class="number">42</span>,<span class="number">49</span></span><br><span class="line"><span class="number">5</span> : <span class="number">56</span></span><br><span class="line"><span class="number">6</span> : </span><br><span class="line"><span class="number">7</span> : <span class="number">71</span></span><br><span class="line"><span class="number">8</span> : </span><br><span class="line"><span class="number">9</span> : <span class="number">194</span>,<span class="number">391</span></span><br></pre></td></tr></table></figure></p>
<p>5.得到第二次比较结果<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>,<span class="number">8</span>,<span class="number">103</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">19</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">127</span>,<span class="number">42</span>,<span class="number">49</span>,<span class="number">56</span>,<span class="number">71</span>,<span class="number">194</span>,<span class="number">391</span></span><br></pre></td></tr></table></figure></p>
<p>6.再对百位进行比较<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> : <span class="number">2</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">19</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">42</span>,<span class="number">49</span>,<span class="number">56</span>,<span class="number">71</span></span><br><span class="line"><span class="number">1</span> : <span class="number">103</span>,<span class="number">127</span>,<span class="number">194</span></span><br><span class="line"><span class="number">2</span> : </span><br><span class="line"><span class="number">3</span> : <span class="number">391</span></span><br><span class="line"><span class="number">4</span> : </span><br><span class="line"><span class="number">5</span> : </span><br><span class="line"><span class="number">6</span> : </span><br><span class="line"><span class="number">7</span> : </span><br><span class="line"><span class="number">8</span> : </span><br><span class="line"><span class="number">9</span> :</span><br></pre></td></tr></table></figure></p>
<p>7.最后得到最终排序后的结果<br>    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">19</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">42</span>,<span class="number">49</span>,<span class="number">56</span>,<span class="number">71</span>,<span class="number">103</span>,<span class="number">127</span>,<span class="number">194</span>,<span class="number">391</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>java 实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 基数排序</span><br><span class="line"> * 按照位数来排序，先从个位一直到最大值得最大位</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> a 待排序数组</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	radixSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span> || start &lt; <span class="number">0</span> || end &gt;= a.length) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 数组最大值</span></span><br><span class="line">	<span class="keyword">int</span> max = a[start];</span><br><span class="line">	<span class="comment">// 遍历选出最大值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; max) &#123;</span><br><span class="line">			max = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最大值得位数，即循环多少次</span></span><br><span class="line">	<span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(max != <span class="number">0</span>) &#123;</span><br><span class="line">		max /= <span class="number">10</span>;</span><br><span class="line">		loop++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 基数数组，从-9 ~ 9</span></span><br><span class="line">	<span class="keyword">int</span>[] radix = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">19</span>];</span><br><span class="line">	<span class="comment">// 临时存储中间数组</span></span><br><span class="line">	<span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> mod = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= loop; i++) &#123;</span><br><span class="line">		<span class="comment">// 基数数组初始化或者还原</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; radix.length; j++) &#123;</span><br><span class="line">			radix[j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 根据当前位数的值对应于基数数组中下标，进行累加</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = end; j &gt;= start; j--) &#123;</span><br><span class="line">			<span class="comment">//当前位数的值， 123 -&gt; 个位为3，十位为2 ...</span></span><br><span class="line">			<span class="keyword">int</span> idx = (a[j] / mod) % <span class="number">10</span>;</span><br><span class="line">			<span class="comment">// 转为基数数组下标</span></span><br><span class="line">			idx += <span class="number">9</span>;</span><br><span class="line">			<span class="comment">// 累计</span></span><br><span class="line">			radix[idx]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 对基数数组中的值进行累计，对应于a中的下标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; radix.length; j++) &#123;</span><br><span class="line">			radix[j] += radix[j - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 根据当前位数的值对应的基数数组的值填充进temp数组中</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = end; j &gt;= start; j--) &#123;</span><br><span class="line">			<span class="keyword">int</span> idx = (a[j] / mod) % <span class="number">10</span>;</span><br><span class="line">			idx += <span class="number">9</span>;</span><br><span class="line">			temp[radix[idx] - <span class="number">1</span>] = a[j];</span><br><span class="line">			radix[idx]--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将temp中的值存入a数组中</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp.length; j++) &#123;</span><br><span class="line">			a[start + j] = temp[j];</span><br><span class="line">		&#125;</span><br><span class="line">		mod *= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="u6876_u6392_u5E8F_28Bucket_sort_29"><a href="#u6876_u6392_u5E8F_28Bucket_sort_29" class="headerlink" title="桶排序(Bucket sort)"></a><a id="bucketSort"></a><a href="https://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="external">桶排序</a>(<a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank" rel="external">Bucket sort</a>)</h2><p>&emsp;&emsp;桶排序不是一个比较排序，其原理是将元素放入特定的某个桶中，然后在桶中进行排序。</p>
<ul>
<li>复杂度与稳定性</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>最差时间复杂度</td>
<td>$O(n^2*k)$</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>$O(n+k)$</td>
</tr>
<tr>
<td>最差空间复杂度</td>
<td>$O(n*k)$</td>
</tr>
<tr>
<td>稳定</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<ul>
<li>桶排序实现步骤</li>
</ul>
<ol>
<li>设置一个定量的数组当作空桶子。</li>
<li>寻访序列，并且把项目一个一个放到对应的桶子去。</li>
<li>对每个不是空的桶子进行排序。</li>
<li>从不是空的桶子里把项目再放回原来的序列中。</li>
</ol>
<ul>
<li>排序实例</li>
</ul>
<ol>
<li><p>待排序数据集合</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">29</span>,<span class="number">18</span>,<span class="number">25</span>,<span class="number">13</span>,<span class="number">20</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">21</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">27</span>,<span class="number">31</span>,<span class="number">22</span>,<span class="number">7</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分成若干个桶，将数据集合按照大小存入特定的桶内</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>-<span class="number">4</span> : <span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span></span><br><span class="line"><span class="number">5</span>-<span class="number">9</span> : <span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span></span><br><span class="line"><span class="number">10</span>-<span class="number">14</span> : <span class="number">13</span>,<span class="number">11</span>,<span class="number">10</span></span><br><span class="line"><span class="number">15</span>-<span class="number">19</span> : <span class="number">18</span>,<span class="number">15</span></span><br><span class="line"><span class="number">20</span>-<span class="number">24</span> : <span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span></span><br><span class="line"><span class="number">25</span>-<span class="number">29</span> : <span class="number">29</span>,<span class="number">25</span>,<span class="number">27</span></span><br><span class="line"><span class="number">30</span>-<span class="number">34</span> : <span class="number">31</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在每个桶内进行排序操作</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>-<span class="number">4</span> : <span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line"><span class="number">5</span>-<span class="number">9</span> : <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span></span><br><span class="line"><span class="number">10</span>-<span class="number">14</span> : <span class="number">10</span>,<span class="number">11</span>,<span class="number">13</span></span><br><span class="line"><span class="number">15</span>-<span class="number">19</span> : <span class="number">15</span>,<span class="number">18</span></span><br><span class="line"><span class="number">20</span>-<span class="number">24</span> : <span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span></span><br><span class="line"><span class="number">25</span>-<span class="number">29</span> : <span class="number">25</span>,<span class="number">27</span>,<span class="number">29</span></span><br><span class="line"><span class="number">30</span>-<span class="number">34</span> : <span class="number">31</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>依次取出桶内的数据，得到最终排好序的数据集合</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">18</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">25</span>,<span class="number">27</span>,<span class="number">29</span>,<span class="number">31</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>算法伪代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">function bucket-sort(<span class="built_in">array</span>, n) is</span><br><span class="line">  buckets ← <span class="keyword">new</span> <span class="built_in">array</span> of n empty lists</span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">0</span> to (length(<span class="built_in">array</span>)-<span class="number">1</span>) <span class="keyword">do</span></span><br><span class="line">    insert <span class="built_in">array</span>[i] into buckets[msbits(<span class="built_in">array</span>[i], k)]</span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">0</span> to n - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    next-sort(buckets[i])</span><br><span class="line">  <span class="keyword">return</span> the concatenation of buckets[<span class="number">0</span>], ..., buckets[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>java 实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 桶排序</span><br><span class="line"> * 根据桶的大小，按顺序放入对应的桶中，最后依次取出桶中元素</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> a 待排序数组</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	bucketSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="keyword">null</span> || start &lt; <span class="number">0</span> || end &gt;= a.length) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 默认一个桶的大小</span></span><br><span class="line">	<span class="keyword">int</span> bucketSize = <span class="number">5</span>;</span><br><span class="line">	<span class="comment">// 数组中最大元素</span></span><br><span class="line">	<span class="keyword">int</span> max = a[start];</span><br><span class="line">	<span class="comment">// 数组中最小元素</span></span><br><span class="line">	<span class="keyword">int</span> min = a[start];</span><br><span class="line">	<span class="comment">// 遍历得到最大最小值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; max) &#123;</span><br><span class="line">			max = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt; min) &#123;</span><br><span class="line">			min = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 桶的数量</span></span><br><span class="line">	<span class="keyword">int</span> count = (max - min) / bucketSize + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 存储桶的二维数组</span></span><br><span class="line">	<span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[count][];</span><br><span class="line">	<span class="comment">// 遍历待排序数组，往桶中插入元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">		<span class="comment">// 桶下标</span></span><br><span class="line">		<span class="keyword">int</span> idx = (a[i] - min) / bucketSize;</span><br><span class="line">		<span class="comment">// 桶中的数组c</span></span><br><span class="line">		<span class="keyword">int</span>[] c = temp[idx];</span><br><span class="line">		<span class="comment">// 插入a[i]元素之后的数组</span></span><br><span class="line">		<span class="keyword">int</span>[] d;</span><br><span class="line">		<span class="comment">// c数组没有元素时，d[0]=a[i]</span></span><br><span class="line">		<span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">			d = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">			d[<span class="number">0</span>] = a[i];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// d数组比c数组多一个元素</span></span><br><span class="line">			d = <span class="keyword">new</span> <span class="keyword">int</span>[c.length + <span class="number">1</span>];</span><br><span class="line">			<span class="comment">// 是否已经插入a[i]元素</span></span><br><span class="line">			<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">			<span class="comment">// c数组中插入a[i]元素得到d数组</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d.length; j++) &#123;</span><br><span class="line">				<span class="comment">// 没有插入的情况下，c数组中的元素大于或等于待插入元素是或者j的值已经为d中最后一个元素时，d[j]=a[i]</span></span><br><span class="line">				<span class="keyword">if</span> (!flag &amp;&amp; (j == c.length || c[j] &gt;= a[i])) &#123;</span><br><span class="line">					d[j] = a[i];</span><br><span class="line">					flag = <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 待插入元素已经插入时</span></span><br><span class="line">					<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">						d[j] = c[j - <span class="number">1</span>];</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						d[j] = c[j];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 桶中数组更新为d数组</span></span><br><span class="line">		temp[idx] = d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 顺序填充</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">		<span class="comment">// 当前桶中无元素</span></span><br><span class="line">		<span class="keyword">if</span> (temp[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp[i].length; j++) &#123;</span><br><span class="line">			a[start + idx] = temp[i][j];</span><br><span class="line">			idx++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h2><p>&emsp;&emsp;常见的排序算法差不多就是上面的几种排序算法：归并排序、快速排序、堆排序、插入排序、希尔排序、基数排序、冒泡排序、选择排序、桶排序，其实排序算法还有很多，二叉查找树排序(Binary tree sort)、<a href="https://zh.wikipedia.org/wiki/%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="external">奇偶排序</a>(<a href="https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort" target="_blank" rel="external">Odd–even sort</a>)、鸡尾酒排序(Cocktail shaker sort)、,还有一些混合排序算法，例如<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E7%9C%81%E6%8E%92%E5%BA%8F" target="_blank" rel="external">内省排序</a>(<a href="https://en.wikipedia.org/wiki/Introsort" target="_blank" rel="external">Introsort</a>),将快速排序和堆排序结合使用，<a href="https://en.wikipedia.org/wiki/Timsort" target="_blank" rel="external">Tim排序</a>，将归并排序和插入排序结合一起使用。Java在1.7之前的数组排序，数据量小的时候使用快速排序，数据量大了使用归并排序，在1.7以后对于基本类型使用改良的双基数快速排序，对象使用Tim排序。要想学习Tim排序可以参考<a href="http://blog.kongfy.com/2012/10/%E8%AF%91%E7%90%86%E8%A7%A3timsort-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E9%80%82%E5%BA%94%E6%80%A7%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8Fadaptive-mergesort/" target="_blank" rel="external">这篇译文</a>。当然还有一些脑洞很大的算法，譬如：bogo排序–将数列随机排列，检查是否排好，没排好的话，继续随机排列。睡眠排序–数列中每一个元素对应一个线程，元素的值对应休眠的时间，根据线程唤醒的先后次序进行排序。排序看上去是个简单的问题，但是确有着大量的研究，有用的新算法仍在不断的被发明。</p>
<p><br><br><br></p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Sorting_algorithm" target="_blank" rel="external">Sorting algorithm</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="external">排序算法</a></li>
<li><a href="http://bubkoo.com/2014/01/17/sort-algorithm/archives" target="_blank" rel="external">常见排序算法</a></li>
<li><a href="http://zh.visualgo.net/sorting" target="_blank" rel="external">可视化排序</a></li>
<li><a href="http://www.sorting-algorithms.com" target="_blank" rel="external">排序算法动画</a></li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/04/07/Quartz应用/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Quartz应用</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="排序" data-title="排序" data-url="http://blog.saisimon.net/2016/06/16/排序/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Saisimon
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>